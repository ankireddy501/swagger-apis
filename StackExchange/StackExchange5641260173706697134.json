{
  "swagger" : "2.0",
  "info" : {
    "description" : "Headline : Stack Exchange is a network of 125 communities that are created and run by experts and enthusiasts like you who are passionate about a specific topic. We build libraries of high-quality questions and answers, focused on each community's area of expertise.",
    "version" : "2.0",
    "title" : "StackExchange"
  },
  "host" : "api.stackexchange.com",
  "basePath" : "/2.0",
  "schemes" : [ "https" ],
  "paths" : {
    "/access-tokens/{accessTokens}/invalidate" : {
      "get" : {
        "summary" : "Immediately expires the access tokens passed. This method is meant to allow an application to discard any active access tokens it no longer needs.\r\n \r\n{accessTokens} can contain up to 20 access tokens. These are obtained by authenticating a user using OAuth 2.0.\r\n \r\nThis method returns a list of access_tokens.\r\n",
        "description" : "Immediately expires the access tokens passed. This method is...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/access_tokens"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "accessTokens",
        "in" : "path",
        "description" : "String list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/apps/{accessTokens}/de-authenticate" : {
      "get" : {
        "summary" : "Passing valid access_tokens to this method causes the application that created them to be de-authorized by the user associated with each access_token. This will remove the application from their apps tab, and cause all other existing access_tokens to be destroyed.\r\n \r\nThis method is meant for uninstalling applications, recovering from access_token leaks, or simply as a stronger form of /access-tokens/{accessTokens}/invalidate.\r\n \r\nNothing prevents a user from re-authenticate to an application that has de-authenticated itself, the user will be prompted to approve the application again however.\r\n \r\n{accessTokens} can contain up to 20 access tokens. These are obtained by authenticating a user using OAuth 2.0.\r\n \r\nThis method returns a list of access_tokens.\r\n",
        "description" : "Passing valid access_tokens to this method causes the applic...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/access_tokens"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "accessTokens",
        "in" : "path",
        "description" : "String list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/badges/name" : {
      "get" : {
        "summary" : "Gets all explicitly named badges in the system.\r\n \r\nA named badged stands in opposition to a tag-based badge. These are referred to as general badges on the sites themselves.\r\n \r\nFor the rank sort, bronze is greater than silver which is greater than gold. Along with sort=rank, set max=gold for just gold badges, max=silver&min=silver for just silver, and min=bronze for just bronze.\r\n \r\nrank is the default sort.\r\n \r\nThis method returns a list of badges.\r\n",
        "description" : "Gets all explicitly named badges in the system.\r\n \r\nA named ba...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = rank => string\r\nsort = name => string\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = rank => string\r\nsort = name => string\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "inname",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/badges"
              }
            }
          }
        }
      }
    },
    "/badges/{ids}/recipients" : {
      "get" : {
        "summary" : "Returns recently awarded badges in the system, constrained to a certain set of badges.\r\n \r\nAs these badges have been awarded, they will have the badge.user property set.\r\n \r\n{ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for badge_id on badge objects.\r\n \r\nThis method returns a list of badges.\r\n",
        "description" : "Returns recently awarded badges in the system, constrained t...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/badges"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "ids",
        "in" : "path",
        "description" : "Number list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/comments/{id}/delete" : {
      "post" : {
        "summary" : "Deletes a comment.\r\n \r\nUse an access_token with write_access to delete a comment.\r\n \r\nIn practice, this method will never return an object.\r\n",
        "description" : "Deletes a comment.\r\n \r\nUse an access_token with write_access t...",
        "operationId" : "POST",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "preview",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : { }
      },
      "parameters" : [ {
        "name" : "id",
        "in" : "path",
        "description" : "(Untitled)",
        "required" : false,
        "type" : "integer",
        "format" : "int32"
      } ]
    },
    "/comments/{id}/edit" : {
      "post" : {
        "summary" : "Edit an existing comment.\r\n \r\nUse an access_token with write_access to edit an existing comment.\r\n \r\nThis method return the created comment.\r\n",
        "description" : "Edit an existing comment.\r\n \r\nUse an access_token with write_a...",
        "operationId" : "POST",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "body",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "preview",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "$ref" : "#/definitions/created_comment"
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "id",
        "in" : "path",
        "description" : "(Untitled)",
        "required" : false,
        "type" : "integer",
        "format" : "int32"
      } ]
    },
    "/errors" : {
      "get" : {
        "summary" : "Returns the various error codes that can be produced by the API.\r\n \r\nThis method is provided for discovery, documentation, and testing purposes, it is not expected many applications will consume it during normal operation.\r\n \r\nFor testing purposes, look into the /errors/{id} method which simulates errors given a code.\r\n \r\nThis method returns a list of errors.\r\n",
        "description" : "Returns the various error codes that can be produced by the ...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/errors"
              }
            }
          }
        }
      }
    },
    "/errors/{id}" : {
      "get" : {
        "summary" : "This method allows you to generate an error.\r\n \r\nThis method is only intended for use when testing an application or library. Unlike other methods in the API, its contract is not frozen, and new error codes may be added at any time.\r\n \r\nThis method results in an error, which will be expressed with a 400 HTTP status code and setting the error* properties on the wrapper object.\r\n",
        "description" : "This method allows you to generate an error.\r\n \r\nThis method i...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "$ref" : "#/definitions/error"
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "id",
        "in" : "path",
        "description" : "(Untitled)",
        "required" : false,
        "type" : "integer",
        "format" : "int32"
      } ]
    },
    "/events" : {
      "get" : {
        "summary" : "Returns a stream of events that have occurred on the site.\r\n \r\nThe API considers the following \"events\":\r\n - posting a question\r\n - posting an answer\r\n - posting a comment\r\n - editing a post\r\n - creating a user\r\n  \r\n \r\nEvents are only accessible for 15 minutes after they occurred, and by default only events in the last 5 minutes are returned. You can specify the age of the oldest event returned by setting the since parameter.\r\n \r\nIt is advised that developers batch events by ids and make as few subsequent requests to other methods as possible.\r\n \r\nThis method returns a list of events.\r\n",
        "description" : "Returns a stream of events that have occurred on the site.\r\n ...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "since",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/events"
              }
            }
          }
        }
      }
    },
    "/filters/create" : {
      "get" : {
        "summary" : "Creates a new filter given a list of includes, excludes, a base filter, and whether or not this filter should be \"unsafe\".\r\n \r\nFilter \"safety\" is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n \r\nIf no base filter is specified, the default filter is assumed. When building a filter from scratch, the none built-in filter is useful.\r\n \r\nWhen the size of the parameters being sent to this method grows to large, problems can occur. This method will accept POST requests to mitigate this.\r\n \r\nIt is not expected that many applications will call this method at runtime, filters should be pre-calculated and \"baked in\" in the common cases. Furthermore, there are a number of built-in filters which cover common use cases.\r\n \r\nThis method returns a single filter.\r\n",
        "description" : "Creates a new filter given a list of includes, excludes, a b...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "base",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "exclude",
          "in" : "query",
          "description" : "String list (semicolon delimited).",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "unsafe",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "include",
          "in" : "query",
          "description" : "String list (semicolon delimited).",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "$ref" : "#/definitions/single_filter"
            }
          }
        }
      }
    },
    "/filters/{filters}" : {
      "get" : {
        "summary" : "Returns the fields included by the given filters, and the \"safeness\" of those filters.\r\n \r\nIt is not expected that this method will be consumed by many applications at runtime, it is provided to aid in debugging.\r\n \r\n{filters} can contain up to 20 semicolon delimited filters. Filters are obtained via calls to /filters/create, or by using a built-in filter.\r\n \r\nThis method returns a list of filters.\r\n",
        "description" : "Returns the fields included by the given filters, and the \"s...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/filters"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "filters",
        "in" : "path",
        "description" : "String list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/me" : {
      "get" : {
        "summary" : "Returns the user associated with the passed access_token.\r\n \r\nThis method returns a user.\r\n",
        "description" : "Returns the user associated with the passed access_token.\r\n \r\n...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = reputation => number\r\nsort = creation => date\r\nsort = name => string\r\nsort = modified => date\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = reputation => number\r\nsort = creation => date\r\nsort = name => string\r\nsort = modified => date\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "$ref" : "#/definitions/user"
            }
          }
        }
      }
    },
    "/me/comments/{toId}" : {
      "get" : {
        "summary" : "Returns the comments owned by the user associated with the given access_token that are in reply to the user identified by {toId}.\r\n \r\nThis method returns a list of comments.\r\n",
        "description" : "Returns the comments owned by the user associated with the g...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/comments"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "toId",
        "in" : "path",
        "description" : "(Untitled)",
        "required" : false,
        "type" : "integer",
        "format" : "int32"
      } ]
    },
    "/posts" : {
      "get" : {
        "summary" : "Fetches all posts (questions and answers) on the site.\r\n \r\nIn many ways this method is the union of /questions and /answers, returning both sets of data albeit only the common fields.\r\n \r\nMost applications should use the question or answer specific methods, but /posts is available for those rare cases where any activity is of intereset. Examples of such queries would be: \"all posts on Jan. 1st 2011\" or \"top 10 posts by score of all time\".\r\n \r\nThe sorts accepted by this method operate on the follow fields of the post object:\r\n - activity - last_activity_date\r\n - creation - creation_date\r\n - votes - score\r\n  activity is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n \r\nThis method returns a list of posts.\r\n",
        "description" : "Fetches all posts (questions and answers) on the site.\r\n \r\nIn ...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/posts"
              }
            }
          }
        }
      }
    },
    "/posts/{ids}/revisions" : {
      "get" : {
        "summary" : "Returns edit revisions for the posts identified in ids.\r\n \r\n{ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for post_id, answer_id, or question_id on post, answer, and question objects respectively.\r\n \r\nThis method returns a list of revisions.\r\n",
        "description" : "Returns edit revisions for the posts identified in ids.\r\n \r\n{i...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/revisions"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "ids",
        "in" : "path",
        "description" : "Number list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/posts/{id}/comments/add" : {
      "post" : {
        "summary" : "Create a new comment.\r\n \r\nUse an access_token with write_access to create a new comment on a post.\r\n \r\nThis method returns the created comment.\r\n",
        "description" : "Create a new comment.\r\n \r\nUse an access_token with write_acces...",
        "operationId" : "POST",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "preview",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "body",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "$ref" : "#/definitions/created_comment"
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "id",
        "in" : "path",
        "description" : "(Untitled)",
        "required" : false,
        "type" : "integer",
        "format" : "int32"
      } ]
    },
    "/questions/{ids}/linked" : {
      "get" : {
        "summary" : "Gets questions which link to those questions identified in {ids}.\r\n \r\nThis method only considers questions that are linked within a site, and will never return questions from another Stack Exchange site.\r\n \r\nA question is considered \"linked\" when it explicitly includes a hyperlink to another question, there are no other heuristics.\r\n \r\n{ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for question_id on question objects.\r\n \r\nThe sorts accepted by this method operate on the follow fields of the question object:\r\n - activity - last_activity_date\r\n - creation - creation_date\r\n - votes - score\r\n - rank - a priority sort by site applies, subject to change at any time Does not accept min or max\r\n  activity is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n \r\nThis method returns a list of questions.\r\n",
        "description" : "Gets questions which link to those questions identified in {...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\nsort = rank => none\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\nsort = rank => none\r\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/questions"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "ids",
        "in" : "path",
        "description" : "Number list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/search" : {
      "get" : {
        "summary" : "Searches a site for any questions which fit the given criteria.\r\n \r\nThis method is intentionally quite limited. For more general searching, you should use a proper internet search engine restricted to the domain of the site in question.\r\n \r\nAt least one of tagged or intitle must be set on this method. nottagged is only used if tagged is also set, for performance reasons.\r\n \r\ntagged and nottagged are semi-colon delimited list of tags. At least 1 tag in tagged will be on each returned question if it is passed, making it the OR equivalent of the AND version of tagged on /questions.\r\n \r\nThe sorts accepted by this method operate on the follow fields of the question object:\r\n - activity - last_activity_date\r\n - creation - creation_date\r\n - votes - score\r\n - relevance - matches the relevance tab on the site itself Does not accept min or max\r\n  activity is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n \r\nThis method returns a list of questions.\r\n",
        "description" : "Searches a site for any questions which fit the given criter...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "nottagged",
          "in" : "query",
          "description" : "String list (semicolon delimited).",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\nsort = relevance => none\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "tagged",
          "in" : "query",
          "description" : "String list (semicolon delimited).",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\nsort = relevance => none\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "intitle",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/questions"
              }
            }
          }
        }
      }
    },
    "/search/advanced" : {
      "get" : {
        "summary" : "Searches a site for any questions which fit the given criteria.\r\n \r\nSearch criteria are expressed using the following parameters:\r\n  - q - a free form text parameter, will match all question properties based on an undocumented algorithm.\r\n - accepted - true to return only questions with accepted answers, false to return only those without. Omit to elide constraint.\r\n - answers - the minimum number of answers returned questions must have.\r\n - body - text which must appear in returned questions' bodies.\r\n - closed - true to return only closed questions, false to return only open ones. Omit to elide constraint.\r\n - migrated - true to return only questions migrated away from a site, false to return only those not. Omit to elide constraint.\r\n - notice - true to return only questions with post notices, false to return only those without. Omit to elide constraint.\r\n - nottagged - a semicolon delimited list of tags, none of which will be present on returned questions.\r\n - tagged - a semicolon delimited list of tags, of which at least one will be present on all returned questions.\r\n - title - text which must appear in returned questions' titles.\r\n - user - the id of the user who must own the questions returned.\r\n - url - a url which must be contained in a post, may include a wildcard.\r\n - views - the minimum number of views returned questions must have.\r\n - wiki - true to return only community wiki questions, false to return only non-community wiki ones. Omit to elide constraint.\r\n  \r\nAt least one additional parameter must be set if nottagged is set, for performance reasons.\r\n \r\nThe sorts accepted by this method operate on the follow fields of the question object:\r\n - activity - last_activity_date\r\n - creation - creation_date\r\n - votes - score\r\n - relevance - matches the relevance tab on the site itself Does not accept min or max\r\n  activity is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n \r\nThis method returns a list of questions.\r\n",
        "description" : "Searches a site for any questions which fit the given criter...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "accepted",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\nsort = relevance => none\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "migrated",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "url",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "tagged",
          "in" : "query",
          "description" : "String list (semicolon delimited).",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "q",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "body",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "notice",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "wiki",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "closed",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "title",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "user",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "nottagged",
          "in" : "query",
          "description" : "String list (semicolon delimited).",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "views",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "answers",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\nsort = relevance => none\r\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/questions"
              }
            }
          }
        }
      }
    },
    "/similar" : {
      "get" : {
        "summary" : "Returns questions which are similar to a hypothetical one based on a title and tag combination.\r\n \r\nThis method is roughly equivalent to a site's related questions suggestion on the ask page.\r\n \r\nThis method is useful for correlating data outside of a Stack Exchange site with similar content within one.\r\n \r\nNote that title must always be passed as a parameter. tagged and nottagged are optional, semi-colon delimited lists of tags.\r\n \r\nIf tagged is passed it is treated as a preference, there is no guarantee that questions returned will have any of those tags. nottagged is treated as a requirement, no questions will be returned with those tags.\r\n \r\nThe sorts accepted by this method operate on the follow fields of the question object:\r\n - activity - last_activity_date\r\n - creation - creation_date\r\n - votes - score\r\n - relevance - order by \"how similar\" the questions are, most likely candidate first with a descending order Does not accept min or max\r\n  activity is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n \r\nThis method returns a list of questions.\r\n",
        "description" : "Returns questions which are similar to a hypothetical one ba...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "max",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\nsort = relevance => none\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "title",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "nottagged",
          "in" : "query",
          "description" : "String list (semicolon delimited).",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\nsort = relevance => none\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "tagged",
          "in" : "query",
          "description" : "String list (semicolon delimited).",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/questions"
              }
            }
          }
        }
      }
    },
    "/sites" : {
      "get" : {
        "summary" : "Returns all sites in the network.\r\n \r\nThis method allows for discovery of new sites, and changes to existing ones. Be aware that unlike normal API methods, this method should be fetched very infrequently, it is very unusual for these values to change more than once on any given day. It is suggested that you cache its return for at least one day, unless your app encounters evidence that it has changed (such as from the /info method).\r\n \r\nThe pagesize parameter for this method is unbounded, in acknowledgement that for many applications repeatedly fetching from /sites would complicate start-up tasks needlessly.\r\n \r\nThis method returns a list of sites.\r\n",
        "description" : "Returns all sites in the network.\r\n \r\nThis method allows for d...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/sites"
              }
            }
          }
        }
      }
    },
    "/tags/moderator-only" : {
      "get" : {
        "summary" : "Returns the tags found on a site that only moderators can use.\r\n \r\nThe inname parameter lets a consumer filter down to tags that contain a certain substring. For example, inname=own would return both \"download\" and \"owner\" amongst others.\r\n \r\nThis method returns a list of tags.\r\n \r\nThe sorts accepted by this method operate on the follow fields of the tag object:\r\n - popular - count\r\n - activity - the creation_date of the last question asked with the tag\r\n - name - name\r\n  popular is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n",
        "description" : "Returns the tags found on a site that only moderators can us...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = popular => number\r\nsort = activity => date\r\nsort = name => string\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "inname",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = popular => number\r\nsort = activity => date\r\nsort = name => string\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/tags"
              }
            }
          }
        }
      }
    },
    "/tags/required" : {
      "get" : {
        "summary" : "Returns the tags found on a site that fulfill required tag constraints on questions.\r\n \r\nThe inname parameter lets a consumer filter down to tags that contain a certain substring. For example, inname=own would return both \"download\" and \"owner\" amongst others.\r\n \r\nThis method returns a list of tags.\r\n \r\nThe sorts accepted by this method operate on the follow fields of the tag object:\r\n - popular - count\r\n - activity - the creation_date of the last question asked with the tag\r\n - name - name\r\n  popular is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n",
        "description" : "Returns the tags found on a site that fulfill required tag c...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = popular => number\r\nsort = activity => date\r\nsort = name => string\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "inname",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = popular => number\r\nsort = activity => date\r\nsort = name => string\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/tags"
              }
            }
          }
        }
      }
    },
    "/tags/{tags}/faq" : {
      "get" : {
        "summary" : "Returns the frequently asked questions for the given set of tags in {tags}.\r\n \r\nFor a question to be returned, it must have all the tags in {tags} and be considered \"frequently asked\". The exact algorithm for determining whether a question is considered a FAQ is subject to change at any time.\r\n \r\n{tags} can contain up to 5 individual tags per request.\r\n \r\nThis method returns a list of questions.\r\n",
        "description" : "Returns the frequently asked questions for the given set of ...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/questions"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "tags",
        "in" : "path",
        "description" : "String list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/tags/{tags}/info" : {
      "get" : {
        "summary" : "Returns tag objects representing the tags in {tags} found on the site.\r\n \r\nThis method diverges from the standard naming patterns to avoid to conflicting with existing methods, due to the free form nature of tag names.\r\n \r\nThis method returns a list of tags.\r\n \r\nThe sorts accepted by this method operate on the follow fields of the tag object:\r\n - popular - count\r\n - activity - the creation_date of the last question asked with the tag\r\n - name - name\r\n  popular is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n",
        "description" : "Returns tag objects representing the tags in {tags} found on...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = popular => number\r\nsort = activity => date\r\nsort = name => string\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = popular => number\r\nsort = activity => date\r\nsort = name => string\r\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/tags"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "tags",
        "in" : "path",
        "description" : "String list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/tags/{tags}/related" : {
      "get" : {
        "summary" : "Returns the tags that are most related to those in {tags}.\r\n \r\nIncluding multiple tags in {tags} is equivalent to asking for \"tags related to tag #1 and tag #2\" not \"tags related to tag #1 or tag #2\".\r\n \r\ncount on tag objects returned is the number of question with that tag that also share all those in {tags}.\r\n \r\n{tags} can contain up to 4 individual tags per request.\r\n \r\nThis method returns a list of tags.\r\n",
        "description" : "Returns the tags that are most related to those in {tags}.\r\n ...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/tags"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "tags",
        "in" : "path",
        "description" : "String list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/tags/{tags}/synonyms" : {
      "get" : {
        "summary" : "Gets all the synonyms that point to the tags identified in {tags}. If you're looking to discover all the tag synonyms on a site, use the /tags/synonyms methods instead of call this method on all tags.\r\n \r\n{tags} can contain up to 20 individual tags per request.\r\n \r\nThe sorts accepted by this method operate on the follow fields of the tag_synonym object:\r\n - creation - creation_date\r\n - applied - applied_count\r\n - activity - last_applied_date\r\n  creation is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n \r\nThis method returns a list of tag synonyms.\r\n",
        "description" : "Gets all the synonyms that point to the tags identified in {...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = creation => date\r\nsort = applied => number\r\nsort = activity => date\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = creation => date\r\nsort = applied => number\r\nsort = activity => date\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/tag_synonyms"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "tags",
        "in" : "path",
        "description" : "String list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/tags/{tags}/wikis" : {
      "get" : {
        "summary" : "Returns the wikis that go with the given set of tags in {tags}.\r\n \r\nBe aware that not all tags have wikis.\r\n \r\n{tags} can contain up to 20 individual tags per request.\r\n \r\nThis method returns a list of tag wikis.\r\n",
        "description" : "Returns the wikis that go with the given set of tags in {tag...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/tag_wikis"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "tags",
        "in" : "path",
        "description" : "String list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/tags/{tag}/top-askers/{period}" : {
      "get" : {
        "summary" : "Returns the top 30 askers active in a single tag, of either all-time or the last 30 days.\r\n \r\nThis is a view onto the data presented on the tag info page on the sites.\r\n \r\nThis method returns a list of tag score objects.\r\n",
        "description" : "Returns the top 30 askers active in a single tag, of either ...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/tag_score_objects"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "tag",
        "in" : "path",
        "description" : "(Untitled)",
        "required" : true,
        "type" : "string"
      }, {
        "name" : "period",
        "in" : "path",
        "description" : "(Untitled)",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/users" : {
      "get" : {
        "summary" : "Returns all users on a site.\r\n \r\nThis method returns a list of users.\r\n \r\nThe sorts accepted by this method operate on the follow fields of the user object:\r\n - reputation - reputation\r\n - creation - creation_date\r\n - name - display_name\r\n - modified - last_modified_date\r\n  reputation is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n \r\nThe inname parameter lets consumers filter the results down to just those users with a certain substring in their display name. For example, inname=kevin will return all users with both users named simply \"Kevin\" or those with Kevin as one of (or part of) their names; such as \"Kevin Montrose\".\r\n",
        "description" : "Returns all users on a site.\r\n \r\nThis method returns a list of...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "max",
          "in" : "query",
          "description" : "sort = reputation => number\r\nsort = creation => date\r\nsort = name => string\r\nsort = modified => date\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "inname",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = reputation => number\r\nsort = creation => date\r\nsort = name => string\r\nsort = modified => date\r\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/users"
              }
            }
          }
        }
      }
    },
    "/users/moderators" : {
      "get" : {
        "summary" : "Gets those users on a site who can exercise moderation powers.\r\n \r\nNote, employees of Stack Exchange Inc. will be returned if they have been granted moderation powers on a site even if they have never been appointed or elected explicitly. This method checks abilities, not the manner in which they were obtained.\r\n \r\nThe sorts accepted by this method operate on the follow fields of the user object:\r\n - reputation - reputation\r\n - creation - creation_date\r\n - name - display_name\r\n - modified - last_modified_date\r\n  reputation is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n \r\nThis method returns a list of users.\r\n",
        "description" : "Gets those users on a site who can exercise moderation power...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = reputation => number\r\nsort = creation => date\r\nsort = name => string\r\nsort = modified => date\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = reputation => number\r\nsort = creation => date\r\nsort = name => string\r\nsort = modified => date\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/users"
              }
            }
          }
        }
      }
    },
    "/users/moderators/elected" : {
      "get" : {
        "summary" : "Returns those users on a site who both have moderator powers, and were actually elected.\r\n \r\nThis method excludes Stack Exchange Inc. employees, unless they were actually elected moderators on a site (which can only have happened prior to their employment).\r\n \r\nThe sorts accepted by this method operate on the follow fields of the user object:\r\n - reputation - reputation\r\n - creation - creation_date\r\n - name - display_name\r\n - modified - last_modified_date\r\n  reputation is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n \r\nThis method returns a list of users.\r\n",
        "description" : "Returns those users on a site who both have moderator powers...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "min",
          "in" : "query",
          "description" : "sort = reputation => number\r\nsort = creation => date\r\nsort = name => string\r\nsort = modified => date\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = reputation => number\r\nsort = creation => date\r\nsort = name => string\r\nsort = modified => date\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/users"
              }
            }
          }
        }
      }
    },
    "/users/{ids}" : {
      "get" : {
        "summary" : "Gets the users identified in ids in {ids}.\r\n \r\nTypically this method will be called to fetch user profiles when you have obtained user ids from some other source, such as /questions.\r\n \r\n{ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.\r\n \r\nThe sorts accepted by this method operate on the follow fields of the user object:\r\n - reputation - reputation\r\n - creation - creation_date\r\n - name - display_name\r\n - modified - last_modified_date\r\n  reputation is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n \r\nThis method returns a list of users.\r\n",
        "description" : "Gets the users identified in ids in {ids}.\r\n \r\nTypically this ...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = reputation => number\r\nsort = creation => date\r\nsort = name => string\r\nsort = modified => date\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = reputation => number\r\nsort = creation => date\r\nsort = name => string\r\nsort = modified => date\r\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/users"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "ids",
        "in" : "path",
        "description" : "Number list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/users/{ids}/answers" : {
      "get" : {
        "summary" : "Returns the answers the users in {ids} have posted.\r\n \r\n{ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.\r\n \r\nThe sorts accepted by this method operate on the follow fields of the answer object:\r\n - activity - last_activity_date\r\n - creation - creation_date\r\n - votes - score\r\n  activity is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n \r\nThis method returns a list of answers.\r\n",
        "description" : "Returns the answers the users in {ids} have posted.\r\n \r\n{ids} ...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "max",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/answers"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "ids",
        "in" : "path",
        "description" : "Number list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/users/{ids}/associated" : {
      "get" : {
        "summary" : "Returns all of a user's associated accounts, given their account_ids in {ids}.\r\n \r\n{ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for account_id on user objects.\r\n \r\nThis method returns a list of network_users.\r\n",
        "description" : "Returns all of a user's associated accounts, given their acc...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/network_users"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "ids",
        "in" : "path",
        "description" : "Number list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/users/{ids}/badges" : {
      "get" : {
        "summary" : "Get the badges the users in {ids} have earned.\r\n \r\nBadge sorts are a tad complicated. For the purposes of sorting (and min/max) tag_based is considered to be greater than named.\r\n \r\nThis means that you can get a list of all tag based badges a user has by passing min=tag_based, and conversely all the named badges by passing max=named, with sort=type.\r\n \r\nFor ranks, bronze is greater than silver which is greater than gold. Along with sort=rank, set max=gold for just gold badges, max=silver&min=silver for just silver, and min=bronze for just bronze.\r\n \r\nrank is the default sort.\r\n \r\n{ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.\r\n \r\nThis method returns a list of badges.\r\n",
        "description" : "Get the badges the users in {ids} have earned.\r\n \r\nBadge sorts...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = rank => string\r\nsort = name => string\r\nsort = type => string\r\nsort = awarded => date\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = rank => string\r\nsort = name => string\r\nsort = type => string\r\nsort = awarded => date\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/badges"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "ids",
        "in" : "path",
        "description" : "Number list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/users/{ids}/comments" : {
      "get" : {
        "summary" : "Get the comments posted by users in {ids}.\r\n \r\n{ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.\r\n \r\nThe sorts accepted by this method operate on the follow fields of the comment object:\r\n - creation - creation_date\r\n - votes - score\r\n  creation is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n \r\nThis method returns a list of comments.\r\n",
        "description" : "Get the comments posted by users in {ids}.\r\n \r\n{ids} can conta...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "min",
          "in" : "query",
          "description" : "sort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/comments"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "ids",
        "in" : "path",
        "description" : "Number list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/users/{ids}/comments/{toid}" : {
      "get" : {
        "summary" : "Get the comments that the users in {ids} have posted in reply to the single user identified in {toid}.\r\n \r\nThis method is useful for extracting conversations, especially over time or across multiple posts.\r\n \r\n{ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects. {toid} can contain only 1 id, found in the same manner as those in {ids}.\r\n \r\nThe sorts accepted by this method operate on the follow fields of the comment object:\r\n - creation - creation_date\r\n - votes - score\r\n  creation is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n \r\nThis method returns a list of comments.\r\n",
        "description" : "Get the comments that the users in {ids} have posted in repl...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/comments"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "toid",
        "in" : "path",
        "description" : "(Untitled)",
        "required" : false,
        "type" : "integer",
        "format" : "int32"
      }, {
        "name" : "ids",
        "in" : "path",
        "description" : "Number list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/users/{ids}/favorites" : {
      "get" : {
        "summary" : "Get the questions that users in {ids} have favorited.\r\n \r\nThis method is effectively a view onto a user's favorites tab.\r\n \r\n{ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.\r\n \r\nThe sorts accepted by this method operate on the follow fields of the question object:\r\n - activity - last_activity_date\r\n - creation - creation_date\r\n - votes - score\r\n - added - when the user favorited the question\r\n  activity is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n \r\nThis method returns a list of questions.\r\n",
        "description" : "Get the questions that users in {ids} have favorited.\r\n \r\nThis...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\nsort = added => date\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\nsort = added => date\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/questions"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "ids",
        "in" : "path",
        "description" : "Number list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/users/{ids}/mentioned" : {
      "get" : {
        "summary" : "Gets all the comments that the users in {ids} were mentioned in.\r\n \r\nNote, to count as a mention the comment must be considered to be \"in reply to\" a user. Most importantly, this means that a comment can only be in reply to a single user.\r\n \r\n{ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.\r\n \r\nThe sorts accepted by this method operate on the follow fields of the comment object:\r\n - creation - creation_date\r\n - votes - score\r\n  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n \r\nThis method returns a list of comments.\r\n",
        "description" : "Gets all the comments that the users in {ids} were mentioned...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/comments"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "ids",
        "in" : "path",
        "description" : "Number list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/users/{ids}/merges" : {
      "get" : {
        "summary" : "Returns a record of merges that have occurred involving the passed account ids.\r\n \r\nThis method allows you to take now invalid account ids and find what account they've become, or take currently valid account ids and find which ids were equivalent in the past.\r\n \r\nThis is most useful when confirming that an account_id is in fact \"new\" to an application.\r\n \r\nAccount merges can happen for a wide range of reasons, applications should not make assumptions that merges have particular causes.\r\n \r\nNote that accounts are managed at a network level, users on a site may be merged due to an account level merge but there is no guarantee that a merge has an effect on any particular site.\r\n \r\nThis method returns a list of account_merge.\r\n",
        "description" : "Returns a record of merges that have occurred involving the ...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/account_merge"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "ids",
        "in" : "path",
        "description" : "Number list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/users/{ids}/questions" : {
      "get" : {
        "summary" : "Gets the questions asked by the users in {ids}.\r\n \r\n{ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.\r\n \r\nThe sorts accepted by this method operate on the follow fields of the question object:\r\n - activity - last_activity_date\r\n - creation - creation_date\r\n - votes - score\r\n  activity is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n \r\nThis method returns a list of questions.\r\n",
        "description" : "Gets the questions asked by the users in {ids}.\r\n \r\n{ids} can ...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/questions"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "ids",
        "in" : "path",
        "description" : "Number list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/users/{ids}/questions/featured" : {
      "get" : {
        "summary" : "Gets the questions on which the users in {ids} have active bounties.\r\n \r\n{ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.\r\n \r\nThe sorts accepted by this method operate on the follow fields of the question object:\r\n - activity - last_activity_date\r\n - creation - creation_date\r\n - votes - score\r\n  activity is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n \r\nThis method returns a list of questions.\r\n",
        "description" : "Gets the questions on which the users in {ids} have active b...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/questions"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "ids",
        "in" : "path",
        "description" : "Number list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/users/{ids}/questions/no-answers" : {
      "get" : {
        "summary" : "Gets the questions asked by the users in {ids} which have no answers.\r\n \r\nQuestions returns by this method actually have zero undeleted answers. It is completely disjoint /users/{ids}/questions/unanswered and /users/{ids}/questions/unaccepted, which only return questions with at least one answer, subject to other contraints.\r\n \r\n{ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.\r\n \r\nThe sorts accepted by this method operate on the follow fields of the question object:\r\n - activity - last_activity_date\r\n - creation - creation_date\r\n - votes - score\r\n  activity is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n \r\nThis method returns a list of questions.\r\n",
        "description" : "Gets the questions asked by the users in {ids} which have no...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/questions"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "ids",
        "in" : "path",
        "description" : "Number list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/users/{ids}/questions/unaccepted" : {
      "get" : {
        "summary" : "Gets the questions asked by the users in {ids} which have at least one answer, but no accepted answer.\r\n \r\nQuestions returned by this method have answers, but the owner has not opted to accept any of them.\r\n \r\n{ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.\r\n \r\nThe sorts accepted by this method operate on the follow fields of the question object:\r\n - activity - last_activity_date\r\n - creation - creation_date\r\n - votes - score\r\n  activity is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n \r\nThis method returns a list of questions.\r\n",
        "description" : "Gets the questions asked by the users in {ids} which have at...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/questions"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "ids",
        "in" : "path",
        "description" : "Number list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/users/{ids}/questions/unanswered" : {
      "get" : {
        "summary" : "Gets the questions asked by the users in {ids} which the site consideres unanswered, while still having at least one answer posted.\r\n \r\nThese rules are subject to change, but currently any question without at least one upvoted or accepted answer is considered unanswered.\r\n \r\nTo get the set of questions that a user probably considers unanswered, the returned questions should be unioned with those returned by /users/{id}/questions/no-answers. These methods are distinct so that truly unanswered (that is, zero posted answers) questions can be easily separated from mearly poorly or inadequately answered ones.\r\n \r\n{ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.\r\n \r\nThe sorts accepted by this method operate on the follow fields of the question object:\r\n - activity - last_activity_date\r\n - creation - creation_date\r\n - votes - score\r\n  activity is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n \r\nThis method returns a list of questions.\r\n",
        "description" : "Gets the questions asked by the users in {ids} which the sit...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/questions"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "ids",
        "in" : "path",
        "description" : "Number list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/users/{ids}/reputation" : {
      "get" : {
        "summary" : "Gets a subset of the reputation changes for users in {ids}.\r\n \r\nReputation changes are intentionally scrubbed of some data to make it difficult to correlate votes on particular posts with user reputation changes. That being said, this method returns enough data for reasonable display of reputation trends.\r\n \r\n{ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.\r\n \r\nThis method returns a list of reputation objects.\r\n",
        "description" : "Gets a subset of the reputation changes for users in {ids}.\r\n...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/reputation_objects"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "ids",
        "in" : "path",
        "description" : "Number list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/users/{ids}/suggested-edits" : {
      "get" : {
        "summary" : "Returns the suggested edits a users in {ids} have submitted.\r\n \r\n{ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.\r\n \r\nThe sorts accepted by this method operate on the follow fields of the suggested_edit object:\r\n - creation - creation_date\r\n - approval - approval_date Does not return unapproved suggested_edits\r\n - rejection - rejection_date Does not return unrejected suggested_edits\r\n  creation is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n \r\nThis method returns a list of suggested-edits.\r\n",
        "description" : "Returns the suggested edits a users in {ids} have submitted....",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = creation => date\r\nsort = approval => date\r\nsort = rejection => date\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = creation => date\r\nsort = approval => date\r\nsort = rejection => date\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/suggested-edits"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "ids",
        "in" : "path",
        "description" : "Number list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/users/{ids}/timeline" : {
      "get" : {
        "summary" : "Returns a subset of the actions the users in {ids} have taken on the site.\r\n \r\nThis method returns users' posts, edits, and earned badges in the order they were accomplished. It is possible to filter to just a window of activity using the fromdate and todate parameters.\r\n \r\n{ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.\r\n \r\nThis method returns a list of user timeline objects.\r\n",
        "description" : "Returns a subset of the actions the users in {ids} have take...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/user_timeline_objects"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "ids",
        "in" : "path",
        "description" : "Number list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/users/{id}/inbox" : {
      "get" : {
        "summary" : "Returns a user's inbox.\r\n \r\nThis method requires an access_token, with a scope containing \"read_inbox\".\r\n \r\nThis method is effectively an alias for /inbox. It is provided for consumers who make strong assumptions about operating within the context of a single site rather than the Stack Exchange network as a whole.\r\n \r\n{id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.\r\n \r\nThis method returns a list of inbox items.\r\n",
        "description" : "Returns a user's inbox.\r\n \r\nThis method requires an access_tok...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/inbox_items"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "id",
        "in" : "path",
        "description" : "(Untitled)",
        "required" : false,
        "type" : "integer",
        "format" : "int32"
      } ]
    },
    "/users/{id}/inbox/unread" : {
      "get" : {
        "summary" : "Returns the unread items in a user's inbox.\r\n \r\nThis method requires an access_token, with a scope containing \"read_inbox\".\r\n \r\nThis method is effectively an alias for /inbox/unread. It is provided for consumers who make strong assumptions about operating within the context of a single site rather than the Stack Exchange network as a whole.\r\n \r\n{id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.\r\n \r\nThis method returns a list of inbox items.\r\n",
        "description" : "Returns the unread items in a user's inbox.\r\n \r\nThis method re...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "since",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/inbox_items"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "id",
        "in" : "path",
        "description" : "(Untitled)",
        "required" : false,
        "type" : "integer",
        "format" : "int32"
      } ]
    },
    "/users/{id}/notifications" : {
      "get" : {
        "summary" : "Returns a user's notifications.\r\n \r\nThis method requires an access_token, with a scope containing \"read_inbox\".\r\n \r\nThis method returns a list of notifications.\r\n",
        "description" : "Returns a user's notifications.\r\n \r\nThis method requires an ac...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/notifications"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "id",
        "in" : "path",
        "description" : "(Untitled)",
        "required" : false,
        "type" : "integer",
        "format" : "int32"
      } ]
    },
    "/users/{id}/privileges" : {
      "get" : {
        "summary" : "Returns the privileges a user has.\r\n \r\nApplications are encouraged to calculate privileges themselves, without repeated queries to this method. A simple check against the results returned by /privileges and user.user_type would be sufficient.\r\n \r\n{id} can contain only a single, to find it programatically look for user_id on user or shallow_user objects.\r\n \r\nThis method returns a list of privileges.\r\n",
        "description" : "Returns the privileges a user has.\r\n \r\nApplications are encour...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/privileges"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "id",
        "in" : "path",
        "description" : "(Untitled)",
        "required" : false,
        "type" : "integer",
        "format" : "int32"
      } ]
    },
    "/users/{id}/reputation-history/full" : {
      "get" : {
        "summary" : "Returns a user's full reputation history, including private events.\r\n \r\nThis method requires an access_token, with a scope containing \"private_info\".\r\n \r\nThis method returns a list of reputation_history.\r\n",
        "description" : "Returns a user's full reputation history, including private ...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/reputation_history"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "id",
        "in" : "path",
        "description" : "(Untitled)",
        "required" : false,
        "type" : "integer",
        "format" : "int32"
      } ]
    },
    "/users/{id}/tags/{tags}/top-answers" : {
      "get" : {
        "summary" : "Returns the top 30 answers a user has posted in response to questions with the given tags.\r\n \r\n{id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects. {tags} is limited to 5 tags, passing more will result in an error.\r\n \r\nThe sorts accepted by this method operate on the follow fields of the answer object:\r\n - activity - last_activity_date\r\n - creation - creation_date\r\n - votes - score\r\n  activity is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n \r\nThis method returns a list of answers.\r\n",
        "description" : "Returns the top 30 answers a user has posted in response to ...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "min",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/answers"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "id",
        "in" : "path",
        "description" : "(Untitled)",
        "required" : false,
        "type" : "integer",
        "format" : "int32"
      }, {
        "name" : "tags",
        "in" : "path",
        "description" : "String list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      } ]
    },
    "/users/{id}/tags/{tags}/top-questions" : {
      "get" : {
        "summary" : "Returns the top 30 questions a user has asked with the given tags.\r\n \r\n{id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects. {tags} is limited to 5 tags, passing more will result in an error.\r\n \r\nThe sorts accepted by this method operate on the follow fields of the question object:\r\n - activity - last_activity_date\r\n - creation - creation_date\r\n - votes - score\r\n  activity is the default sort.\r\n \r\n It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.\r\n \r\nThis method returns a list of questions.\r\n",
        "description" : "Returns the top 30 questions a user has asked with the given...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "min",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "order",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "todate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "fromdate",
          "in" : "query",
          "description" : "Unix date.",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "max",
          "in" : "query",
          "description" : "sort = activity => date\r\nsort = creation => date\r\nsort = votes => number\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/questions"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "tags",
        "in" : "path",
        "description" : "String list (semicolon delimited).",
        "required" : false,
        "type" : "string"
      }, {
        "name" : "id",
        "in" : "path",
        "description" : "(Untitled)",
        "required" : false,
        "type" : "integer",
        "format" : "int32"
      } ]
    },
    "/users/{id}/top-answer-tags" : {
      "get" : {
        "summary" : "Returns a single user's top tags by answer score.\r\n \r\nThis a subset of the data returned on a user's tags tab.\r\n \r\n{id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.\r\n \r\nThis method returns a list of top_tag objects.\r\n",
        "description" : "Returns a single user's top tags by answer score.\r\n \r\nThis a s...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/top_tag_objects"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "id",
        "in" : "path",
        "description" : "(Untitled)",
        "required" : false,
        "type" : "integer",
        "format" : "int32"
      } ]
    },
    "/users/{id}/top-question-tags" : {
      "get" : {
        "summary" : "Returns a single user's top tags by question score.\r\n \r\nThis a subset of the data returned on a user's tags tab.\r\n \r\n{id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.\r\n \r\nThis method returns a list of top_tag objects.\r\n",
        "description" : "Returns a single user's top tags by question score.\r\n \r\nThis a...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/top_tag_objects"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "id",
        "in" : "path",
        "description" : "(Untitled)",
        "required" : false,
        "type" : "integer",
        "format" : "int32"
      } ]
    },
    "/users/{id}/write-permissions" : {
      "get" : {
        "summary" : "Returns the write permissions a user has via the api.\r\n \r\nThe Stack Exchange API gives users the ability to create, edit, and delete certain types. This method returns whether the passed user is capable of performing those actions at all, as well as how many times a day they can.\r\n \r\nThis method does not consider the user's current quota (ie. if they've already exhausted it for today) nor any additional restrictions on write access, such as editing deleted comments.\r\n \r\nThis method returns a list of write_permissions.\r\n",
        "description" : "Returns the write permissions a user has via the api.\r\n \r\nThe ...",
        "operationId" : "GET",
        "consumes" : [ ],
        "parameters" : [ {
          "name" : "callback",
          "in" : "query",
          "description" : "All API responses are JSON, we do support JSONP with the callback query parameter.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "site",
          "in" : "query",
          "description" : "Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \"stackoverflow.com\"), or a short form identified by api_site_parameter on the site object.\r\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "pagesize",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "filter",
          "in" : "query",
          "description" : "#Discussion\r\n\r\nThe Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.\r\n\r\nAn application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.\r\n\r\nFilters are immutable and non-expiring. An application can safely \"bake in\" any filters that are created, it is not necessary (or advisable) to create filters at runtime.\r\n\r\nThe motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).\r\n\r\n#Safety\r\n\r\nFilters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.\r\n\r\nNote that this does not mean that \"safe\" filter is mearly an \"unsafe\" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).\r\n\r\nWhen using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \"safe\" data is the only accessible data it will be returned even in \"unsafe\" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.\r\n\r\n#Built In Filters\r\n\r\nThe following filters are built in:\r\n\r\ndefault, each type documents which fields are returned under the default filter (for example, answers).\r\nwithbody, which is default plus the *.body fields\r\nnone, which is empty\r\ntotal, which includes just .total\r\n\r\n#Compatibility with V1.x\r\n\r\nFor ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.\r\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "(Untitled)",
          "required" : false,
          "type" : "integer",
          "format" : "int32"
        } ],
        "responses" : {
          "200" : {
            "description" : "(Untitled)",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/write_permissions"
              }
            }
          }
        }
      },
      "parameters" : [ {
        "name" : "id",
        "in" : "path",
        "description" : "(Untitled)",
        "required" : false,
        "type" : "integer",
        "format" : "int32"
      } ]
    }
  },
  "definitions" : {
    "network_users" : {
      "properties" : {
        "account_id" : {
          "type" : "integer"
        },
        "answer_count" : {
          "type" : "integer"
        },
        "badge_counts" : {
          "type" : "object",
          "properties" : {
            "bronze" : {
              "type" : "integer"
            },
            "gold" : {
              "type" : "integer"
            },
            "silver" : {
              "type" : "integer"
            }
          }
        },
        "creation_date" : {
          "type" : "integer"
        },
        "last_access_date" : {
          "type" : "integer"
        },
        "question_count" : {
          "type" : "integer"
        },
        "reputation" : {
          "type" : "integer"
        },
        "site_name" : {
          "type" : "string"
        },
        "site_url" : {
          "type" : "string"
        },
        "top_questions" : {
          "type" : "array"
        },
        "user_id" : {
          "type" : "integer"
        },
        "user_type" : {
          "type" : "string"
        }
      }
    },
    "privileges" : {
      "properties" : {
        "description" : {
          "type" : "string"
        },
        "reputation" : {
          "type" : "integer"
        },
        "short_description" : {
          "type" : "string"
        }
      }
    },
    "tag_score_objects" : {
      "properties" : {
        "post_count" : {
          "type" : "integer"
        },
        "score" : {
          "type" : "integer"
        },
        "user" : {
          "type" : "object",
          "properties" : {
            "accept_rate" : {
              "type" : "integer"
            },
            "badge_counts" : {
              "type" : "object",
              "properties" : {
                "bronze" : {
                  "type" : "integer"
                },
                "gold" : {
                  "type" : "integer"
                },
                "silver" : {
                  "type" : "integer"
                }
              }
            },
            "display_name" : {
              "type" : "string"
            },
            "link" : {
              "type" : "string"
            },
            "profile_image" : {
              "type" : "string"
            },
            "reputation" : {
              "type" : "integer"
            },
            "user_id" : {
              "type" : "integer"
            },
            "user_type" : {
              "type" : "string"
            }
          }
        }
      }
    },
    "created_comment" : {
      "type" : "object",
      "properties" : {
        "body" : {
          "type" : "string"
        },
        "body_markdown" : {
          "type" : "string"
        },
        "can_flag" : {
          "type" : "boolean"
        },
        "comment_id" : {
          "type" : "integer"
        },
        "creation_date" : {
          "type" : "integer"
        },
        "edited" : {
          "type" : "boolean"
        },
        "link" : {
          "type" : "string"
        },
        "owner" : {
          "type" : "object",
          "properties" : {
            "accept_rate" : {
              "type" : "integer"
            },
            "badge_counts" : {
              "type" : "object",
              "properties" : {
                "bronze" : {
                  "type" : "integer"
                },
                "gold" : {
                  "type" : "integer"
                },
                "silver" : {
                  "type" : "integer"
                }
              }
            },
            "display_name" : {
              "type" : "string"
            },
            "link" : {
              "type" : "string"
            },
            "profile_image" : {
              "type" : "string"
            },
            "reputation" : {
              "type" : "integer"
            },
            "user_id" : {
              "type" : "integer"
            },
            "user_type" : {
              "type" : "string"
            }
          }
        },
        "post_id" : {
          "type" : "integer"
        },
        "post_type" : {
          "type" : "string"
        },
        "reply_to_user" : {
          "type" : "object",
          "properties" : {
            "accept_rate" : {
              "type" : "integer"
            },
            "badge_counts" : {
              "type" : "object",
              "properties" : {
                "bronze" : {
                  "type" : "integer"
                },
                "gold" : {
                  "type" : "integer"
                },
                "silver" : {
                  "type" : "integer"
                }
              }
            },
            "display_name" : {
              "type" : "string"
            },
            "link" : {
              "type" : "string"
            },
            "profile_image" : {
              "type" : "string"
            },
            "reputation" : {
              "type" : "integer"
            },
            "user_id" : {
              "type" : "integer"
            },
            "user_type" : {
              "type" : "string"
            }
          }
        },
        "score" : {
          "type" : "integer"
        },
        "upvoted" : {
          "type" : "boolean"
        }
      }
    },
    "comments" : {
      "properties" : {
        "body" : {
          "type" : "string"
        },
        "body_markdown" : {
          "type" : "string"
        },
        "can_flag" : {
          "type" : "boolean"
        },
        "comment_id" : {
          "type" : "integer"
        },
        "creation_date" : {
          "type" : "integer"
        },
        "edited" : {
          "type" : "boolean"
        },
        "link" : {
          "type" : "string"
        },
        "owner" : {
          "type" : "object",
          "properties" : {
            "accept_rate" : {
              "type" : "integer"
            },
            "badge_counts" : {
              "type" : "object",
              "properties" : {
                "bronze" : {
                  "type" : "integer"
                },
                "gold" : {
                  "type" : "integer"
                },
                "silver" : {
                  "type" : "integer"
                }
              }
            },
            "display_name" : {
              "type" : "string"
            },
            "link" : {
              "type" : "string"
            },
            "profile_image" : {
              "type" : "string"
            },
            "reputation" : {
              "type" : "integer"
            },
            "user_id" : {
              "type" : "integer"
            },
            "user_type" : {
              "type" : "string"
            }
          }
        },
        "post_id" : {
          "type" : "integer"
        },
        "post_type" : {
          "type" : "string"
        },
        "reply_to_user" : {
          "type" : "object",
          "properties" : {
            "accept_rate" : {
              "type" : "integer"
            },
            "badge_counts" : {
              "type" : "object",
              "properties" : {
                "bronze" : {
                  "type" : "integer"
                },
                "gold" : {
                  "type" : "integer"
                },
                "silver" : {
                  "type" : "integer"
                }
              }
            },
            "display_name" : {
              "type" : "string"
            },
            "link" : {
              "type" : "string"
            },
            "profile_image" : {
              "type" : "string"
            },
            "reputation" : {
              "type" : "integer"
            },
            "user_id" : {
              "type" : "integer"
            },
            "user_type" : {
              "type" : "string"
            }
          }
        },
        "score" : {
          "type" : "integer"
        },
        "upvoted" : {
          "type" : "boolean"
        }
      }
    },
    "reputation_objects" : {
      "properties" : {
        "link" : {
          "type" : "string"
        },
        "on_date" : {
          "type" : "integer"
        },
        "post_id" : {
          "type" : "integer"
        },
        "post_type" : {
          "type" : "string"
        },
        "reputation_change" : {
          "type" : "integer"
        },
        "title" : {
          "type" : "string"
        },
        "user_id" : {
          "type" : "integer"
        },
        "vote_type" : {
          "type" : "string"
        }
      }
    },
    "tag_synonyms" : {
      "properties" : {
        "applied_count" : {
          "type" : "integer"
        },
        "creation_date" : {
          "type" : "integer"
        },
        "from_tag" : {
          "type" : "string"
        },
        "last_applied_date" : {
          "type" : "integer"
        },
        "to_tag" : {
          "type" : "string"
        }
      }
    },
    "filters" : {
      "properties" : {
        "filter" : {
          "type" : "string"
        },
        "filter_type" : {
          "type" : "string"
        }
      }
    },
    "error" : {
      "type" : "object",
      "properties" : {
        "error_id" : {
          "type" : "number"
        },
        "error_message" : {
          "type" : "string"
        },
        "error_name" : {
          "type" : "string"
        }
      }
    },
    "access_tokens" : {
      "properties" : {
        "access_token" : {
          "type" : "string"
        },
        "account_id" : {
          "type" : "integer"
        },
        "expires_on_date" : {
          "type" : "integer"
        }
      }
    },
    "tag_wikis" : {
      "properties" : {
        "body" : {
          "type" : "string"
        },
        "body_last_edit_date" : {
          "type" : "integer"
        },
        "excerpt" : {
          "type" : "string"
        },
        "excerpt_last_edit_date" : {
          "type" : "integer"
        },
        "last_body_editor" : {
          "type" : "object",
          "properties" : {
            "accept_rate" : {
              "type" : "integer"
            },
            "badge_counts" : {
              "type" : "object",
              "properties" : {
                "bronze" : {
                  "type" : "integer"
                },
                "gold" : {
                  "type" : "integer"
                },
                "silver" : {
                  "type" : "integer"
                }
              }
            },
            "display_name" : {
              "type" : "string"
            },
            "link" : {
              "type" : "string"
            },
            "profile_image" : {
              "type" : "string"
            },
            "reputation" : {
              "type" : "integer"
            },
            "user_id" : {
              "type" : "integer"
            },
            "user_type" : {
              "type" : "string"
            }
          }
        },
        "last_excerpt_editor" : {
          "type" : "object",
          "properties" : {
            "accept_rate" : {
              "type" : "integer"
            },
            "badge_counts" : {
              "type" : "object",
              "properties" : {
                "bronze" : {
                  "type" : "integer"
                },
                "gold" : {
                  "type" : "integer"
                },
                "silver" : {
                  "type" : "integer"
                }
              }
            },
            "display_name" : {
              "type" : "string"
            },
            "link" : {
              "type" : "string"
            },
            "profile_image" : {
              "type" : "string"
            },
            "reputation" : {
              "type" : "integer"
            },
            "user_id" : {
              "type" : "integer"
            },
            "user_type" : {
              "type" : "string"
            }
          }
        },
        "tag_name" : {
          "type" : "string"
        }
      }
    },
    "account_merge" : {
      "properties" : {
        "merge_date" : {
          "type" : "integer"
        },
        "new_account_id" : {
          "type" : "integer"
        },
        "old_account_id" : {
          "type" : "integer"
        }
      }
    },
    "users" : {
      "properties" : {
        "about_me" : {
          "type" : "string"
        },
        "accept_rate" : {
          "type" : "integer"
        },
        "account_id" : {
          "type" : "integer"
        },
        "age" : {
          "type" : "integer"
        },
        "answer_count" : {
          "type" : "integer"
        },
        "badge_counts" : {
          "type" : "object",
          "properties" : {
            "bronze" : {
              "type" : "integer"
            },
            "gold" : {
              "type" : "integer"
            },
            "silver" : {
              "type" : "integer"
            }
          }
        },
        "creation_date" : {
          "type" : "integer"
        },
        "display_name" : {
          "type" : "string"
        },
        "down_vote_count" : {
          "type" : "integer"
        },
        "is_employee" : {
          "type" : "boolean"
        },
        "last_access_date" : {
          "type" : "integer"
        },
        "last_modified_date" : {
          "type" : "integer"
        },
        "link" : {
          "type" : "string"
        },
        "location" : {
          "type" : "string"
        },
        "profile_image" : {
          "type" : "string"
        },
        "question_count" : {
          "type" : "integer"
        },
        "reputation" : {
          "type" : "integer"
        },
        "reputation_change_day" : {
          "type" : "integer"
        },
        "reputation_change_month" : {
          "type" : "integer"
        },
        "reputation_change_quarter" : {
          "type" : "integer"
        },
        "reputation_change_week" : {
          "type" : "integer"
        },
        "reputation_change_year" : {
          "type" : "integer"
        },
        "timed_penalty_date" : {
          "type" : "integer"
        },
        "up_vote_count" : {
          "type" : "integer"
        },
        "user_id" : {
          "type" : "integer"
        },
        "user_type" : {
          "type" : "string"
        },
        "view_count" : {
          "type" : "integer"
        },
        "website_url" : {
          "type" : "string"
        }
      }
    },
    "tags" : {
      "properties" : {
        "count" : {
          "type" : "integer"
        },
        "has_synonyms" : {
          "type" : "boolean"
        },
        "is_moderator_only" : {
          "type" : "boolean"
        },
        "is_required" : {
          "type" : "boolean"
        },
        "last_activity_date" : {
          "type" : "integer"
        },
        "name" : {
          "type" : "string"
        },
        "user_id" : {
          "type" : "integer"
        }
      }
    },
    "badges" : {
      "properties" : {
        "award_count" : {
          "type" : "integer"
        },
        "badge_id" : {
          "type" : "integer"
        },
        "badge_type" : {
          "type" : "string"
        },
        "description" : {
          "type" : "string"
        },
        "link" : {
          "type" : "string"
        },
        "name" : {
          "type" : "string"
        },
        "rank" : {
          "type" : "string"
        },
        "user" : {
          "type" : "object",
          "properties" : {
            "accept_rate" : {
              "type" : "integer"
            },
            "badge_counts" : {
              "type" : "object",
              "properties" : {
                "bronze" : {
                  "type" : "integer"
                },
                "gold" : {
                  "type" : "integer"
                },
                "silver" : {
                  "type" : "integer"
                }
              }
            },
            "display_name" : {
              "type" : "string"
            },
            "link" : {
              "type" : "string"
            },
            "profile_image" : {
              "type" : "string"
            },
            "reputation" : {
              "type" : "integer"
            },
            "user_id" : {
              "type" : "integer"
            },
            "user_type" : {
              "type" : "string"
            }
          }
        }
      }
    },
    "top_tag_objects" : {
      "properties" : {
        "answer_count" : {
          "type" : "integer"
        },
        "answer_score" : {
          "type" : "integer"
        },
        "question_count" : {
          "type" : "integer"
        },
        "question_score" : {
          "type" : "integer"
        },
        "tag_name" : {
          "type" : "string"
        },
        "user_id" : {
          "type" : "integer"
        }
      }
    },
    "user_timeline_objects" : {
      "properties" : {
        "badge_id" : {
          "type" : "integer"
        },
        "comment_id" : {
          "type" : "integer"
        },
        "creation_date" : {
          "type" : "integer"
        },
        "detail" : {
          "type" : "string"
        },
        "link" : {
          "type" : "string"
        },
        "post_id" : {
          "type" : "integer"
        },
        "post_type" : {
          "type" : "string"
        },
        "suggested_edit_id" : {
          "type" : "integer"
        },
        "timeline_type" : {
          "type" : "string"
        },
        "title" : {
          "type" : "string"
        },
        "user_id" : {
          "type" : "integer"
        }
      }
    },
    "single_filter" : {
      "type" : "object",
      "properties" : {
        "filter" : {
          "type" : "string"
        },
        "filter_type" : {
          "type" : "string"
        }
      }
    },
    "suggested-edits" : {
      "properties" : {
        "approval_date" : {
          "type" : "integer"
        },
        "body" : {
          "type" : "string"
        },
        "comment" : {
          "type" : "string"
        },
        "creation_date" : {
          "type" : "integer"
        },
        "post_id" : {
          "type" : "integer"
        },
        "post_type" : {
          "type" : "string"
        },
        "proposing_user" : {
          "type" : "object",
          "properties" : {
            "accept_rate" : {
              "type" : "integer"
            },
            "badge_counts" : {
              "type" : "object",
              "properties" : {
                "bronze" : {
                  "type" : "integer"
                },
                "gold" : {
                  "type" : "integer"
                },
                "silver" : {
                  "type" : "integer"
                }
              }
            },
            "display_name" : {
              "type" : "string"
            },
            "link" : {
              "type" : "string"
            },
            "profile_image" : {
              "type" : "string"
            },
            "reputation" : {
              "type" : "integer"
            },
            "user_id" : {
              "type" : "integer"
            },
            "user_type" : {
              "type" : "string"
            }
          }
        },
        "rejection_date" : {
          "type" : "integer"
        },
        "suggested_edit_id" : {
          "type" : "integer"
        },
        "title" : {
          "type" : "string"
        }
      }
    },
    "reputation_history" : {
      "properties" : {
        "creation_date" : {
          "type" : "integer"
        },
        "post_id" : {
          "type" : "integer"
        },
        "reputation_change" : {
          "type" : "integer"
        },
        "reputation_history_type" : {
          "type" : "string"
        },
        "user_id" : {
          "type" : "integer"
        }
      }
    },
    "user" : {
      "type" : "object",
      "properties" : {
        "about_me" : {
          "type" : "string"
        },
        "accept_rate" : {
          "type" : "integer"
        },
        "account_id" : {
          "type" : "integer"
        },
        "age" : {
          "type" : "integer"
        },
        "answer_count" : {
          "type" : "integer"
        },
        "badge_counts" : {
          "type" : "object",
          "properties" : {
            "bronze" : {
              "type" : "integer"
            },
            "gold" : {
              "type" : "integer"
            },
            "silver" : {
              "type" : "integer"
            }
          }
        },
        "creation_date" : {
          "type" : "integer"
        },
        "display_name" : {
          "type" : "string"
        },
        "down_vote_count" : {
          "type" : "integer"
        },
        "is_employee" : {
          "type" : "boolean"
        },
        "last_access_date" : {
          "type" : "integer"
        },
        "last_modified_date" : {
          "type" : "integer"
        },
        "link" : {
          "type" : "string"
        },
        "location" : {
          "type" : "string"
        },
        "profile_image" : {
          "type" : "string"
        },
        "question_count" : {
          "type" : "integer"
        },
        "reputation" : {
          "type" : "integer"
        },
        "reputation_change_day" : {
          "type" : "integer"
        },
        "reputation_change_month" : {
          "type" : "integer"
        },
        "reputation_change_quarter" : {
          "type" : "integer"
        },
        "reputation_change_week" : {
          "type" : "integer"
        },
        "reputation_change_year" : {
          "type" : "integer"
        },
        "timed_penalty_date" : {
          "type" : "integer"
        },
        "up_vote_count" : {
          "type" : "integer"
        },
        "user_id" : {
          "type" : "integer"
        },
        "user_type" : {
          "type" : "string"
        },
        "view_count" : {
          "type" : "integer"
        },
        "website_url" : {
          "type" : "string"
        }
      }
    },
    "write_permissions" : {
      "properties" : {
        "can_add" : {
          "type" : "boolean"
        },
        "can_delete" : {
          "type" : "boolean"
        },
        "can_edit" : {
          "type" : "boolean"
        },
        "max_daily_actions" : {
          "type" : "integer"
        },
        "min_seconds_between_actions" : {
          "type" : "integer"
        },
        "object_type" : {
          "type" : "string"
        },
        "user_id" : {
          "type" : "integer"
        }
      }
    },
    "events" : {
      "properties" : {
        "creation_date" : {
          "type" : "integer"
        },
        "event_type" : {
          "type" : "string"
        },
        "excerpt" : {
          "type" : "string"
        },
        "link" : {
          "type" : "string"
        },
        "the id of the object (answer, comment, question, or user) the event describes" : {
          "type" : "integer"
        }
      }
    },
    "errors" : {
      "properties" : {
        "description" : {
          "type" : "string"
        },
        "error_id" : {
          "type" : "integer"
        },
        "error_name" : {
          "type" : "string"
        }
      }
    }
  }
}